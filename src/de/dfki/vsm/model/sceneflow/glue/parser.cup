package de.dfki.vsm.model.sceneflow.glue;
// Other Imports
import java_cup.runtime.*;
import java.util.ArrayList;
import java.io.StringReader;
// Different Commands
import de.dfki.vsm.model.sceneflow.glue.command.Command;
import de.dfki.vsm.model.sceneflow.glue.command.Definition;
import de.dfki.vsm.model.sceneflow.glue.command.Assignment;
import de.dfki.vsm.model.sceneflow.glue.command.Invocation;
import de.dfki.vsm.model.sceneflow.glue.command.Expression;
// Definition Commands
import de.dfki.vsm.model.sceneflow.glue.command.definition.FunctionDefinition;
import de.dfki.vsm.model.sceneflow.glue.command.definition.VariableDefinition;
import de.dfki.vsm.model.sceneflow.glue.command.definition.ArgumentDefinition;
import de.dfki.vsm.model.sceneflow.glue.command.definition.DataTypeDefinition;
// Datatype Definitions
import de.dfki.vsm.model.sceneflow.glue.command.definition.datatype.ListTypeDefinition;
import de.dfki.vsm.model.sceneflow.glue.command.definition.datatype.StructTypeDefinition;
import de.dfki.vsm.model.sceneflow.glue.command.definition.datatype.MemberDefinition;
// Invocation Commands
import de.dfki.vsm.model.sceneflow.glue.command.invocation.HistorySetDepth;
import de.dfki.vsm.model.sceneflow.glue.command.invocation.HistoryClearFlat;
import de.dfki.vsm.model.sceneflow.glue.command.invocation.HistoryClearDeep;
import de.dfki.vsm.model.sceneflow.glue.command.invocation.PlayDialogAction;
import de.dfki.vsm.model.sceneflow.glue.command.invocation.PlaySceneGroup;
import de.dfki.vsm.model.sceneflow.glue.command.invocation.PlayActionCommand;
import de.dfki.vsm.model.sceneflow.glue.command.invocation.UnblockSceneGroup;
import de.dfki.vsm.model.sceneflow.glue.command.invocation.UnblockSceneScript;
// Different Expressions
import de.dfki.vsm.model.sceneflow.glue.command.expression.UnaryExpression;
import de.dfki.vsm.model.sceneflow.glue.command.expression.BinaryExpression;
import de.dfki.vsm.model.sceneflow.glue.command.expression.TernaryExpression;
import de.dfki.vsm.model.sceneflow.glue.command.expression.JavaCallExpression;
import de.dfki.vsm.model.sceneflow.glue.command.expression.JavaNewExpression;
import de.dfki.vsm.model.sceneflow.glue.command.expression.VariableExpression;
import de.dfki.vsm.model.sceneflow.glue.command.expression.LiteralExpression;
import de.dfki.vsm.model.sceneflow.glue.command.expression.ParenExpression;
// Literal Expressions
import de.dfki.vsm.model.sceneflow.glue.command.expression.literal.NullLiteral;
import de.dfki.vsm.model.sceneflow.glue.command.expression.literal.IntLiteral;
import de.dfki.vsm.model.sceneflow.glue.command.expression.literal.FloatLiteral;
import de.dfki.vsm.model.sceneflow.glue.command.expression.literal.BoolLiteral;
import de.dfki.vsm.model.sceneflow.glue.command.expression.literal.StringLiteral;
// Record Expressions
import de.dfki.vsm.model.sceneflow.glue.command.expression.record.ArrayExpression;
import de.dfki.vsm.model.sceneflow.glue.command.expression.record.StructExpression;
// Variable Expressions
import de.dfki.vsm.model.sceneflow.glue.command.expression.variable.SimpleVariable;
import de.dfki.vsm.model.sceneflow.glue.command.expression.variable.MemberVariable;
import de.dfki.vsm.model.sceneflow.glue.command.expression.variable.ArrayVariable;
// Function Expressions
import de.dfki.vsm.model.sceneflow.glue.command.expression.invocation.HistoryContains;
import de.dfki.vsm.model.sceneflow.glue.command.expression.invocation.HistoryRunTimeOf;
import de.dfki.vsm.model.sceneflow.glue.command.expression.invocation.HistoryValueOf;
import de.dfki.vsm.model.sceneflow.glue.command.expression.invocation.InStateCond;
import de.dfki.vsm.model.sceneflow.glue.command.expression.invocation.PrologQuery;
import de.dfki.vsm.model.sceneflow.glue.command.expression.invocation.TimeoutCond;


parser code {:
  public static Command cmdResult;
  public static Expression expResult;
  //public static /*de.dfki.vsm.model.sceneflow.command.expression.condition.Condition*/Expression cndResult;
  //public static /*de.dfki.vsm.model.sceneflow.command.expression.condition.logical.LogicalCond*/Expression logResult;
 
  public static final short CMD = 0;
  public static final short EXP = 1;
  //public static final short CND = 2;
  //public static final short LOG = 3;
  //public static final short CONST = 4;

  public static short parseResultType = 0;
  public static boolean errorFlag = false;

  public static String trimString(String value) {    
    return value.substring(1, value.length()-1);
  }

  public static Command run(final String input) throws Exception {
    System.err.println("Parsing Input String '" + input + "'");
    try {
        // Create A String Reader
        final StringReader reader = new StringReader(input);
        // Create A Chart Lexxer
        final ChartLexxer lexxer = new ChartLexxer(reader);
        // Create A Chart Parser
        final ChartParser parser = new ChartParser(lexxer);
        // Parse Input Content
        final Symbol symbol = parser.parse();
        // Cast The Symbol Down
        if(symbol != null) {
            System.err.println("Parsing Result:\n" + symbol.value);  
            //
            return (Command)symbol.value;
        } else {
            return null;
        }
    } catch(final Exception exc) {
        System.err.println("Parsing Error:\n" + exc.toString());  
        return null;
    }



    //cmdResult=null;
    //expResult=null;



  //  cndResult=null;
  //  logResult=null;
    //constResult=null;
 
    //String inputString = new String(arg);
    //final StringReader reader = new StringReader(input);
    //new ChartParser(new ChartLexxer(reader)).parse();
  }
:};

terminal 
    INC, DEC, ANDAND, OROR, EQUALEQUAL, NOTEQUAL, LESS, GREATER, LESSEQUAL, GREATEREQUAL, 
    ARROW, PLUS, MINUS, TIMES, DIV, MOD, LNOT, NOT, AND, XOR, OR,
    LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, COMMA, DOT, QUESTION, COLON, EQUAL; 

//terminal GET, REMOVE, ADDFIRST, ADDLAST, RANDOM, REMOVEFIRST, REMOVELAST, FIRST, LAST, CLEAR, SIZE, CONTAINS, DEFAULT, IN, EMPTY;

terminal 
    PlayDialogAct, 
    PlaySceneGroup,  
    UnblockSceneGroup, 
    UnblockSceneScript, 
    PlayActionCommand, 
    PlayActionSequential, 
    PlayActionConcurrent;
terminal 
    HistoryClearFlat, 
    HistoryClearDeep, 
    HistoryContains, 
    HistoryValueOf, 
    HistorySetDepth, 
    HistoryRunTimeOf;
terminal Query;
terminal Timeout; 
terminal JavaNew;
terminal java.lang.String Identifier;
terminal java.lang.Integer Integer; 
terminal java.lang.Float Floating; 
terminal java.lang.Boolean Boolean;
terminal java.lang.String DQString;
terminal java.lang.Object JavaNull;
// Typenames
terminal String TINT;
terminal String TSHORT;
terminal String TLONG;
terminal String TFLOAT;
terminal String TDOUBLE;
terminal String TBOOL;
terminal String TCHAR;
terminal String TSTRING;
terminal FUN, OBJ, CLASS;

////////////////////////////////////////////////////////////////////////////////
// Commands
non terminal Command command;
non terminal Invocation invocation;
non terminal Assignment assignment;
non terminal Expression expression;
////////////////////////////////////////////////////////////////////////////////
// Definitions
non terminal Command definition;
non terminal FunctionDefinition function_definition;
non terminal VariableDefinition variable_definition;
non terminal ArgumentDefinition argument_definition;
non terminal DataTypeDefinition datatype_definition;
non terminal Definition classpath_definition;
////////////////////////////////////////////////////////////////////////////////
// Datatype Definitions
non terminal ListTypeDefinition list_type_definition;
non terminal StructTypeDefinition struct_type_definition;
non terminal MemberDefinition member_definition;
////////////////////////////////////////////////////////////////////////////////
// Expressions
non terminal UnaryExpression unary_expression;
non terminal BinaryExpression binary_expression;
non terminal TernaryExpression conditional_expression;
non terminal Expression reflection_expression;
non terminal LiteralExpression literal_expression;
non terminal VariableExpression variable_expression;
non terminal ParenExpression paren_expression;
non terminal JavaNewExpression new_expression;
non terminal JavaCallExpression call_expression;

non terminal Expression record_expression;
non terminal Expression invocation_expression;
////////////////////////////////////////////////////////////////////////////////
// Lists
non terminal ArrayList assignment_list;
non terminal ArrayList assignment_list_opt;
non terminal ArrayList expression_list;
non terminal ArrayList expression_list_opt;
non terminal ArrayList member_definition_list;
non terminal ArrayList argument_definition_list;
////////////////////////////////////////////////////////////////////////////////
// Other Non Terminals
non terminal String primitive_type;
non terminal String type_identifier;
non terminal String class_qualifier;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Operator Precedences
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
precedence right EQUAL;
precedence right COLON, QUESTION;
precedence left OROR;
precedence left ANDAND;
precedence left OR;
precedence left XOR;
precedence left AND;
precedence left EQUALEQUAL, NOTEQUAL;
precedence left LESS, LESSEQUAL, GREATER, GREATEREQUAL;
precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD;
precedence right JavaNew;
precedence right NOT, LNOT, INC, DEC;
precedence left DOT;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Command Definitions
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
command ::=
  definition:x  {: RESULT = x; :}
| assignment:x  {: RESULT = x; :}
| invocation:x  {: RESULT = x; :}
| expression:x  {: RESULT = x; :}
;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Different Definitions
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
definition ::=
  datatype_definition:x                                                         {: RESULT = x; :}                                     
| variable_definition:x                                                         {: RESULT = x; :}   
| function_definition:x                                                         {: RESULT = x; :} 
| classpath_definition:x                                                        {: RESULT = x; :} 
;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Datatype Definitions
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
datatype_definition ::=
  list_type_definition:x                                                        {: RESULT = x; :}
| struct_type_definition:x                                                      {: RESULT = x; :}
;
list_type_definition ::=
  Identifier:x COLON LPAREN primitive_type:y RPAREN                             {: RESULT = new ListTypeDefinition(x, y); :} 
;
struct_type_definition ::=
  Identifier:x COLON LPAREN member_definition_list:y RPAREN                     {: RESULT = new StructTypeDefinition(x, y); :} 
;
member_definition ::=
  Identifier:x COLON primitive_type:y                                           {: RESULT = new MemberDefinition(x, y); :} 
;
member_definition_list::=
                                                                                {: ArrayList vec = new ArrayList(); RESULT = vec; :}
| member_definition:x                                                           {: ArrayList vec = new ArrayList(); vec.add(x); RESULT = vec; :}
| member_definition_list:x COMMA member_definition:y                            {: ArrayList vec = x; vec.add(y); RESULT = x; :}
;
primitive_type ::=
  TINT:x                                                                        {: RESULT = x; :}
| TSHORT:x                                                                      {: RESULT = x; :}
| TLONG:x                                                                       {: RESULT = x; :}
| TFLOAT:x                                                                      {: RESULT = x; :}
| TDOUBLE:x                                                                     {: RESULT = x; :}
| TBOOL:x                                                                       {: RESULT = x; :}
| TCHAR:x                                                                       {: RESULT = x; :}
| TSTRING:x                                                                     {: RESULT = x; :}
;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Variable Definitions
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
variable_definition ::=
  type_identifier:x Identifier:y EQUAL expression:z                             {: RESULT = new VariableDefinition(x, y, z); :}
;
type_identifier::=
  primitive_type:x                                                              {: RESULT = x; :}
| Identifier:x                                                                  {: RESULT = x; :}
;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Function Definitions
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
function_definition ::=
  Identifier:x COLON LPAREN class_qualifier:y COMMA Identifier:z RPAREN         {: RESULT = new FunctionDefinition(x, y, z); :} 
| Identifier:x COLON LPAREN class_qualifier:y COMMA Identifier:z 
    COMMA argument_definition_list:l RPAREN                                    {: RESULT = new FunctionDefinition(x, y, z, l); :} 
;
argument_definition_list ::=
  argument_definition:x                                                        {: ArrayList vec = new ArrayList(); vec.add(x); RESULT = vec; :}
| argument_definition_list:x COMMA argument_definition:y                        {: ArrayList vec = x; vec.add(y); RESULT = x; :}
;
argument_definition ::=
  Identifier:x COLON class_qualifier:y                                          {: RESULT = new ArgumentDefinition(x, y); :} 
;
class_qualifier ::=
  Identifier:x                                                                  {: RESULT = x; :}
| class_qualifier:x DOT Identifier:y                                            {: RESULT = x + "." + y; :}
;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Classpath Definitions
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
classpath_definition ::=
  Identifier:x COLON CLASS LPAREN class_qualifier:y RPAREN                      {: System.err.println("Class Path Definition '" + y + "'"); RESULT = null; :} 
;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Variable Assignments
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
assignment ::=
  variable_expression:x EQUAL expression:y                                      {: RESULT = new Assignment(x, y); :}
;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Assignment Lists
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
assignment_list_opt ::=
                                                                                {: ArrayList vec = new ArrayList(); RESULT = vec; :}
| assignment_list:x                                                             {: RESULT = x; :}
;
assignment_list ::=
  assignment:x                                                                  {: ArrayList vec = new ArrayList(); vec.add(x); RESULT = vec; :}
| assignment_list:x COMMA assignment:y                                          {: ArrayList vec = x; vec.add(y); RESULT = x; :}
;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Invocation Commands
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
invocation ::=
  PlayDialogAct LPAREN expression:x RPAREN                                    {: RESULT = new PlayDialogAction(x);  :}
| PlayDialogAct LPAREN expression:x COMMA expression_list:y RPAREN            {: RESULT = new PlayDialogAction(x,y);  :}
| PlaySceneGroup LPAREN expression:x RPAREN                                   {: RESULT = new PlaySceneGroup(x);  :}
| PlaySceneGroup LPAREN expression:x COMMA expression_list:y RPAREN           {: RESULT = new PlaySceneGroup(x,y);  :}
| PlayActionCommand LPAREN expression:x RPAREN                                {: RESULT = new PlayActionCommand(x, PlayActionCommand.ExecutionMode.Default);  :}
| PlayActionCommand LPAREN expression:x COMMA expression_list:y RPAREN        {: RESULT = new PlayActionCommand(x, y, PlayActionCommand.ExecutionMode.Default);  :}
| PlayActionConcurrent LPAREN expression:x RPAREN                             {: RESULT = new PlayActionCommand(x, PlayActionCommand.ExecutionMode.Concurrent);  :}
| PlayActionConcurrent LPAREN expression:x COMMA expression_list:y RPAREN     {: RESULT = new PlayActionCommand(x,y, PlayActionCommand.ExecutionMode.Concurrent);  :}
| PlayActionSequential LPAREN expression:x RPAREN                             {: RESULT = new PlayActionCommand(x, PlayActionCommand.ExecutionMode.Sequential); :}
| PlayActionSequential LPAREN expression:x COMMA expression_list:y RPAREN     {: RESULT = new PlayActionCommand(x, y, PlayActionCommand.ExecutionMode.Sequential); :}
| UnblockSceneGroup LPAREN expression:x RPAREN                                {: RESULT = new UnblockSceneGroup(x);  :}
| UnblockSceneScript LPAREN Boolean:x RPAREN                                  {: RESULT = new UnblockSceneScript(x);  :}
| HistoryClearFlat LPAREN Identifier:x RPAREN                                 {: RESULT = new HistoryClearFlat(x);  :}
| HistoryClearDeep LPAREN Identifier:x RPAREN                                 {: RESULT = new HistoryClearDeep(x);  :}
| HistorySetDepth LPAREN Identifier:x COMMA Integer:y RPAREN                  {: RESULT = new HistorySetDepth(x,y);  :}
;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Expression Lists
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
expression_list_opt ::= 
                                                                                {: ArrayList vec = new ArrayList(); RESULT = vec; :}
| expression_list:x                                                             {: RESULT = x; :}
;
expression_list ::=
  expression:x                                                                  {: ArrayList vec = new ArrayList(); vec.add(x); RESULT = vec; :}
| expression_list:x COMMA expression:y                                          {: ArrayList vec = x; vec.add(y); RESULT = x; :}
;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Expressions
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
expression ::=
  unary_expression:x                                                            {: RESULT = x;  :}
| binary_expression:x                                                           {: RESULT = x;  :}
| conditional_expression:x                                                      {: RESULT = x;  :}
| invocation_expression:x                                                       {: RESULT = x;  :}                                                 
| reflection_expression:x                                                       {: RESULT = x;  :}                                                 
| variable_expression:x                                                         {: RESULT = x;  :}
| record_expression:x                                                           {: RESULT = x;  :}
| literal_expression:x                                                          {: RESULT = x;  :}
| paren_expression:x                                                            {: RESULT = x;  :}
;
unary_expression ::=
  // Logical unary expressions 
  NOT expression:x                                                              {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.Not); :}
  // Unary arithmetric expressions
| MINUS expression:x                                                            {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.Neg); :}
| LNOT expression:x                                                             {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.Lnot); :}
| INC expression:x                                                              {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.Inc); :}
| DEC expression:x                                                              {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.Dec); :}
;  
binary_expression ::=
  expression:x AND expression:y                                                 {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.And, y); :}
| expression:x OR expression:y                                                  {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Or, y); :}
| expression:x XOR expression:y                                                 {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Xor, y); :}
  // Logical binary expressions
| expression:x ANDAND expression:y                                              {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.AndAnd, y); System.err.println("Parsing Binary AndAnd '" + x + "'"); :}
| expression:x OROR expression:y                                                {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.OrOr, y); :}
  // Binary comparison expressions
| expression:x LESS expression:y                                                {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Lt, y); System.err.println("Parsing Binary Lt '" + x + "'"); :}
| expression:x GREATER expression:y                                             {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Gt, y); :}
| expression:x LESSEQUAL expression:y                                           {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Le, y); :}
| expression:x GREATEREQUAL expression:y                                        {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Ge, y); :}
| expression:x EQUALEQUAL expression:y                                          {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Eq, y); System.err.println("Parsing Binary Eq '" + x + "'"); :}
| expression:x NOTEQUAL expression:y                                            {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Neq, y); :}
  // Binary arithmetric expressions
| expression:x PLUS expression:y                                                {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Add, y); :}
| expression:x MINUS expression:y                                               {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Sub, y); :}
| expression:x TIMES expression:y                                               {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Mul, y); :}
| expression:x DIV expression:y                                                 {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Div, y); :}
| expression:x MOD expression:y                                                 {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Mod, y); :}
;
conditional_expression ::=
  LPAREN expression:x QUESTION expression:y COLON expression:z RPAREN           {: RESULT = new TernaryExpression(x, y, z); :}
;
reflection_expression ::=
  call_expression:x                                                             {: RESULT = x;  :}
| new_expression:x                                                              {: RESULT = x;  :}
;
new_expression ::=
  JavaNew Identifier:x LPAREN expression_list_opt:y RPAREN                              {: RESULT = new JavaNewExpression(x, y); :}
;
call_expression ::=
  Identifier:x LPAREN expression_list_opt:y RPAREN                                  {: RESULT = new JavaCallExpression(x, y); :}
;
variable_expression ::=
  Identifier:x                                                                  {: RESULT = new SimpleVariable(x); :}
| Identifier:x LBRACK expression:y RBRACK                                       {: RESULT = new ArrayVariable(x, y); :}
| Identifier:x DOT Identifier:y                                                 {: RESULT = new MemberVariable(x, y); :}
;
invocation_expression ::=
  // State expression
  //IN LPAREN Identifier:x RPAREN                                                 {: RESULT = new InStateCond(x); :}
  // Query expression
  Query LPAREN expression:x RPAREN                                              {: RESULT = new PrologQuery(x); :}
  // Timeout expression 
| Timeout LPAREN expression:x RPAREN                                            {: RESULT = new TimeoutCond(x); :}
  // Random expression
//| RANDOM LPAREN expression:x RPAREN                                             {: RESULT = null; :}
  // History expression
//| HISTORY_VALUE_OF LPAREN Identifier:x COMMA Identifier:y COMMA Integer:z RPAREN{: RESULT = new HistoryValueOf(x, y, z); :}
//| HISTORY_VALUE_OF LPAREN Identifier:x COMMA Identifier:y RPAREN                {: RESULT = new HistoryValueOf(x, y); :}
//| HISTORY_RUNTIME LPAREN Identifier:x COMMA Integer:y RPAREN                    {: RESULT = new HistoryRunTime(x, y); :}
//| HISTORY_RUNTIME LPAREN Identifier:x RPAREN                                    {: RESULT = new HistoryRunTime(x); :}
 // List expression
//| GET LPAREN expression:x COMMA expression:y RPAREN                            {: RESULT = null; :}
//| REMOVE LPAREN expression:x COMMA expression:y RPAREN                          {: RESULT = null; :}
//| CONTAINS LPAREN expression:x COMMA expression:y RPAREN                        {: RESULT = null; :}
//| ADDFIRST LPAREN expression:x COMMA expression:y RPAREN                        {: RESULT = null; :}
//| ADDLAST LPAREN expression:x COMMA expression:y RPAREN                         {: RESULT = null; :}
//| REMOVEFIRST LPAREN expression:x RPAREN                                        {: RESULT = null; :}
//| REMOVELAST LPAREN expression:x RPAREN                                         {: RESULT = null; :}
//| FIRST LPAREN expression:x RPAREN                                              {: RESULT = null; :}
//| LAST LPAREN expression:x RPAREN                                               {: RESULT = null; :}
//| CLEAR LPAREN expression:x RPAREN                                              {: RESULT = null; :}
//| EMPTY LPAREN expression:x RPAREN                                              {: RESULT = null; :}
//| SIZE LPAREN expression:x RPAREN                                               {: RESULT = null; :}
;
record_expression ::=
  LBRACK expression_list_opt:x RBRACK                                           {: RESULT = new ArrayExpression(x); :}
| LBRACE assignment_list_opt:x RBRACE                                           {: RESULT = new StructExpression(x); :}
;
literal_expression ::=
  JavaNull                                                                      {: RESULT = new NullLiteral(); :}
| Boolean:x                                                                     {: RESULT = new BoolLiteral(x); :}
| Integer:x                                                                     {: RESULT = new IntLiteral(x); :}
| Floating:x                                                                    {: RESULT = new FloatLiteral(x); :}
| DQString:x                                                                    {: RESULT = new StringLiteral(ChartParser.trimString(x)); :}
;
paren_expression ::=
  LPAREN expression:x RPAREN                                                    {: RESULT = new ParenExpression(x); System.err.println("Parsing ParenExpression '" + x + "'"); :}
;