package de.dfki.vsm.model.script;

import de.dfki.vsm.util.ios.IndentWriter;
import de.dfki.vsm.util.xml.XMLParseAction;
import de.dfki.vsm.util.xml.XMLParseError;
import de.dfki.vsm.util.xml.XMLWriteError;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.TreeSet;
import org.w3c.dom.Element;

/**
 * @author Gregor Mehlmann
 */
public final class SceneScript extends SceneEntity{

    // The List Of Scenes
    private LinkedList<SceneObject> mSceneList
            = new LinkedList<>();
    // Map Of Scene Groups
    private HashMap<String, SceneGroup> mGroupMap
            = new HashMap<>();

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    public SceneScript() {
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    public SceneScript(
            final int lower,
            final int upper,
            final LinkedList<SceneObject> list) {
        super(lower, upper);
        // Initialize The List
        mSceneList = list;
        // Initialize The Groups
        initGroupMap();
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    public final void initGroupMap() {
        // First Clear The Groups
        mGroupMap.clear();
        // Initialize The Groups
        for (final SceneObject scene : mSceneList) {
            // Get The Group Name
            final String name = scene.getName();
            // Add Scene To Group
            if (mGroupMap.get(name) == null) {
                mGroupMap.put(name, new SceneGroup(name));
            }
            mGroupMap.get(name).add(scene);
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    public final LinkedList<SceneObject> getSceneList() {
        return mSceneList;
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    public final void setSceneList(final LinkedList<SceneObject> list) {
        mSceneList = list;
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    public final LinkedList<SceneObject> copySceneList() {
        // Construct A List Copy
        final LinkedList<SceneObject> copy
                = new LinkedList<>();
        // Copy Each Single Member
        for (final SceneObject scene : mSceneList) {
            copy.add(scene.getCopy());
        }
        // Return The Final Clone
        return copy;
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    public final HashMap<String, SceneGroup> getGroupMap() {
        return mGroupMap;
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    public final TreeSet<SceneGroup> getOrderedGroupSet() {
        return new TreeSet(mGroupMap.values());
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    public final SceneGroup getGroup(final String name) {
        return mGroupMap.get(name);
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    public final boolean isEmpty() {
        return mSceneList.isEmpty();
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    public final int getSize() {
        return mSceneList.size();
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    @Override
    public final String getText() {
        String result = "";
        for (int i = 0; i < mSceneList.size(); i++) {
            result += mSceneList.get(i).getText();
            if (i < mSceneList.size() - 1) {
                result += "\n\n";
            }
        }
        return result;
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    @Override
    public final String getText(final HashMap<String, String> args) {
        String result = "";
        for (int i = 0; i < mSceneList.size(); i++) {
            result += mSceneList.get(i).getText(args);
            if (i < mSceneList.size() - 1) {
                result += "\n\n";
            }
        }
        return result;
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    @Override
    public final SceneScript getCopy() {
        return new SceneScript(mLower, mUpper, copySceneList());
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    @Override
    public final void writeXML(final IndentWriter stream) throws XMLWriteError {
        stream.println("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
        stream.println("<SceneScript "
                + "lower=\"" + mLower + "\" "
                + "upper=\"" + mUpper + "\" "
                + "length=\"" + mSceneList.size() + "\">");
        stream.push();
        for (final SceneObject scene : mSceneList) {
            scene.writeXML(stream);
            if (!scene.equals(mSceneList.getLast())) {
                stream.endl();
            }
        }
        stream.pop();
        stream.endl();
        stream.print("</SceneScript>");
        stream.flush();
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    @Override
    public final void parseXML(final Element element) throws XMLParseError {
        // Parse The Boundary
        mLower = Integer.parseInt(element.getAttribute("lower"));
        mUpper = Integer.parseInt(element.getAttribute("upper"));
        // Process The Child Nodes 
        XMLParseAction.processChildNodes(element, new XMLParseAction() {

            @Override
            public void run(Element element) throws XMLParseError {
                // Create A New Token Style 
                final SceneObject scene = new SceneObject();
                // Parse The New Token Style
                scene.parseXML(element);
                // Put The New Style To The Map
                mSceneList.add(scene);
            }
        });
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    public final void parseTXT(final String text) {
        // Parse Content Into Scene Script
        final SceneScript script = ScriptParser.run(
                "", text, false, false, false, false);
        // Copy Content If Successfully
        if (script != null) {
            // Initialize The Scene List
            mSceneList = script.getSceneList();
            // Initialize The Group Map
            initGroupMap();
        } else {
            mSceneList.clear();
            mGroupMap.clear();
        }
    }
}
