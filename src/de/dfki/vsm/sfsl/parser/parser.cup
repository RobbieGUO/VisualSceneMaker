package de.dfki.vsm.sfsl.parser;

// Different Commands
import de.dfki.vsm.model.sceneflow.language.command.Command;
import de.dfki.vsm.model.sceneflow.language.command.Assignment;
import de.dfki.vsm.model.sceneflow.language.command.Invocation;
import de.dfki.vsm.model.sceneflow.language.command.Expression;
// Invocation Commands
import de.dfki.vsm.model.sceneflow.language.command.invocation.HistorySetDepth;
import de.dfki.vsm.model.sceneflow.language.command.invocation.HistoryFlatClear;
import de.dfki.vsm.model.sceneflow.language.command.invocation.HistoryDeepClear;
import de.dfki.vsm.model.sceneflow.language.command.invocation.PlayDialogAct;
import de.dfki.vsm.model.sceneflow.language.command.invocation.PlaySceneGroup;
import de.dfki.vsm.model.sceneflow.language.command.invocation.UnblockSceneGroup;
import de.dfki.vsm.model.sceneflow.language.command.invocation.UnblockSceneScript;
// Different Expressions
import de.dfki.vsm.model.sceneflow.language.command.expression.VariableExpression;
import de.dfki.vsm.model.sceneflow.language.command.expression.LiteralExpression;
import de.dfki.vsm.model.sceneflow.language.command.expression.UnaryExpression;
import de.dfki.vsm.model.sceneflow.language.command.expression.BinaryExpression;
import de.dfki.vsm.model.sceneflow.language.command.expression.CallingExpression;
import de.dfki.vsm.model.sceneflow.language.command.expression.TernaryExpression;
import de.dfki.vsm.model.sceneflow.language.command.expression.ConstructExpression;
import de.dfki.vsm.model.sceneflow.language.command.expression.ParenthesesExpression;
// Literal Expressions
import de.dfki.vsm.model.sceneflow.language.command.expression.literal.NullObject;
import de.dfki.vsm.model.sceneflow.language.command.expression.literal.IntLiteral;
import de.dfki.vsm.model.sceneflow.language.command.expression.literal.FloatLiteral;
import de.dfki.vsm.model.sceneflow.language.command.expression.literal.BoolLiteral;
import de.dfki.vsm.model.sceneflow.language.command.expression.literal.StringLiteral;
// Record Expressions
import de.dfki.vsm.model.sceneflow.language.command.expression.record.ListRecord;
import de.dfki.vsm.model.sceneflow.language.command.expression.record.StructRecord;
// Variable Expressions
import de.dfki.vsm.model.sceneflow.language.command.expression.variable.SimpleVariable;
import de.dfki.vsm.model.sceneflow.language.command.expression.variable.MemberVariable;
import de.dfki.vsm.model.sceneflow.language.command.expression.variable.ArrayVariable;
// Function Expressions
import de.dfki.vsm.model.sceneflow.language.command.expression.invocation.HistoryContains;
import de.dfki.vsm.model.sceneflow.language.command.expression.invocation.HistoryRunTime;
import de.dfki.vsm.model.sceneflow.language.command.expression.invocation.HistoryValueOf;
import de.dfki.vsm.model.sceneflow.language.command.expression.invocation.InStateCond;
import de.dfki.vsm.model.sceneflow.language.command.expression.invocation.PrologQuery;
import de.dfki.vsm.model.sceneflow.language.command.expression.invocation.TimeoutFunction;

import java.util.ArrayList;
import java.io.StringReader;

parser code {:
  public static Command cmdResult;
  public static Expression expResult;
 
  public static final short STATEMENT = 0;
  public static final short EXPRESSION = 1;

  public static short parseResultType = 0;
  public static boolean errorFlag = false;

  public static java.lang.String trimString(java.lang.String value) {    
    return value.substring(1, value.length()-1);
  }

  public static void run(java.lang.String arg) throws Exception {
    cmdResult=null;
    expResult=null;

    System.err.println("Parsing Input String '" + arg + "'"); 

    java.lang.String inputString = new java.lang.String(arg);
    StringReader stringReader = new java.io.StringReader(inputString);
    new _SFSLParser_(new _SFSLScanner_(stringReader)).parse();
  }
:};

// Binary Logical Operators
terminal OR;
terminal AND; 

// Binary/Unary Arithmetric
terminal DIV; 
terminal PLUS; 
terminal MINUS; 
terminal TIMES; 

// Binary List Operators
terminal GET; 
terminal REMOVE; 
terminal ADDFIRST; 
terminal ADDLAST; 

// Binary Comparison Operators
terminal EQUALEQUAL; 
terminal NOTEQUAL; 
terminal LESS; 
terminal GREATER; 
terminal LESSEQUAL; 
terminal GREATEREQUAL;

//
terminal RANDOM; 
terminal REMOVEFIRST; 
terminal REMOVELAST; 
terminal FIRST; 
terminal LAST; 
terminal CLEAR; 
terminal SIZE; 
terminal EMPTY;
terminal CONTAINS;

// Symbols
terminal LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, COMMA, QUESTION, COLON, DOT;

// Unary Operators
terminal NOT; 

// Equality Operator
terminal EQUAL;

//
terminal PLAY_DIALOG_ACT;
terminal PLAY_SCENE_GROUP;
terminal UNBLOCK_SCENE_GROUP;
terminal UNBLOCK_SCENE_SCRIPT;
//
terminal HISTORY_FLAT_CLEAR;
terminal HISTORY_DEEP_CLEAR;
terminal HISTORY_SET_DEPTH;
//
terminal HISTORY_CONTAINS;
terminal HISTORY_VALUE_OF;
terminal HISTORY_RUNTIME;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal TIMEOUT;
terminal QUERY;
terminal NEW;
terminal IN;
//
terminal String VARIABLE;
terminal Integer INTEGER; 
terminal Float FLOAT; 
terminal Boolean BOOLEAN;
terminal String STRING;
terminal Object NULL;

// Commands
non terminal Command command;
non terminal Invocation invocation;
non terminal Assignment assignment;
non terminal Expression expression;
// Expressions
non terminal UnaryExpression unary_expression;
non terminal BinaryExpression binary_expression;
non terminal TernaryExpression ternary_expression;
non terminal Expression record_expression;
non terminal Expression parentheses_expression;
non terminal Expression invocation_expression;
non terminal Expression timeout_function;
non terminal LiteralExpression literal_expression;
non terminal ArrayList expression_list;
non terminal ArrayList assignment_list;
non terminal ArrayList non_empty_expression_list;
// Invocations
non terminal InStateCond instate_condition;
non terminal TimeoutCond timeout;
non terminal HistoryValueOf history_value_of;
non terminal HistoryRunTime history_runtime_of;
non terminal PrologQuery prolog_condition;
non terminal ConstructExpression construct_expression;
non terminal CallingExpression calling_expression;
non terminal VariableExpression variable_expression;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Operator Precedences
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
precedence right EQUAL;
precedence left OR;
precedence left AND;
precedence left EQUALEQUAL, NOTEQUAL;
precedence left LESS, LESSEQUAL, GREATER, GREATEREQUAL;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence right NOT;
precedence left DOT;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Command Definitions
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
command ::=
  expression:x                                                                  {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } :}
| assignment:x                                                                  {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("Error: The parse result Type Is Not Command"); _SFSLParser_.errorFlag = true; } :}
| invocation:x                                                                  {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("Error: The parse result Type Is Not Command"); _SFSLParser_.errorFlag = true; } :}
;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Assignment Commands
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
assignment ::=
  variable_expression:x EQUAL expression:y                                      {: RESULT = new Assignment(x, y); :};

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Assignment Lists
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
assignment_list ::=
                                                                                {: ArrayList<Assignment> vec = new ArrayList<Assignment>(); RESULT = vec; :}
| assignment:x                                                                  {: ArrayList<Assignment> vec = new ArrayList<Assignment>(); vec.add(x); RESULT = vec; :}
| assignment_list:x COMMA assignment:y                                          {: ArrayList<Assignment> vec = x; vec.add(y); RESULT = x; :};

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Invocation Commands
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
invocation_command ::=
  //
  PLAY_SCENE_GROUP LPAREN expression:x RPAREN                                                {: RESULT = new PlaySceneGroup(x); if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| PLAY_DIALOG_ACT LPAREN expression:x RPAREN                                                {: RESULT = new PlayDialogueAct(x); if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
  //
| PLAY_SCENE_GROUP LPAREN expression:x COMMA non_empty_expression_list:y RPAREN              {: RESULT = new PlaySceneGroup(x,y); if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| PLAY_DIALOG_ACT LPAREN expression:x COMMA non_empty_expression_list:y RPAREN              {: RESULT = new PlayDialogueAct(x,y); if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
  //
| UNBLOCK_SCENE_GROUP LPAREN expression:x RPAREN                                                {: RESULT = new UnblockSceneGroup(x); if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| UNBLOCK_SCENE_SCRIPT LPAREN BOOLEAN:x RPAREN                                                  {: RESULT = new UnblockAllSceneGroups(x); if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
  //
| HISTORY_FLAT_CLEAR LPAREN VARIABLE:x RPAREN                                     {: RESULT = new HistoryClear(x); if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| HISTORY_DEEP_CLEAR LPAREN VARIABLE:x RPAREN                                     {: RESULT = new HistoryDeepClear(x); if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| HISTORY_SET_DEPTH LPAREN VARIABLE:x COMMA INTEGER:y RPAREN                      {: RESULT = new HistorySetDepth(x,y); if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Expression Lists
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
non_empty_expression_list ::=
  expression:x                                                                  {: ArrayList<Expression> vec = new ArrayList<Expression>(); vec.add(x); RESULT = vec; :}
| expression_list:x COMMA expression:y                                          {: ArrayList<Expression> vec = x; vec.add(y); RESULT = x; :};


expression_list ::= 
                                                                                {: ArrayList<Expression> vec = new ArrayList<Expression>(); RESULT = vec; :}
| expression:x                                                                  {: ArrayList<Expression> vec = new ArrayList<Expression>(); vec.add(x); RESULT = vec; :}
| expression_list:x COMMA expression:y                                          {: ArrayList<Expression> vec = x; vec.add(y); RESULT = x; :};

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Expressions
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
expression ::=
  unary_expression:x                                                            {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| binary_expression:x                                                           {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| ternary_expression:x                                                          {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| record_expression:x                                                           {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| calling_expression:x                                                          {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| variable_expression:x                                                         {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| literal_expression:x                                                          {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| construct_expression:x                                                        {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| invocation_expression:x                                                                    {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| parentheses_expression:x                                                      {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
;

ternary_expression ::=
  LPAREN expression:x QUESTION expression:y COLON expression:z RPAREN           {: RESULT = new TernaryExpression(x, y, z); :}
;

parentheses_expression ::=
  LPAREN expression:x RPAREN                                                    {: RESULT = new ParenthesesExpression(x); :}
;

construct_expression ::=
  NEW VARIABLE:x LPAREN expression_list:y RPAREN                                {: RESULT = new ConstructExpression(x, y); :}
;

calling_expression ::=
  VARIABLE:x LPAREN expression_list:y RPAREN                                    {: RESULT = new CallingExpression(x, y); :}
;

binary_expression ::=
  // Logical binary expressions
  expression:x AND expression:y                                                 {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.And, y); :}
| expression:x OR expression:y                                                  {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Or, y); :}
  // Binary comparison expressions
| expression:x LESS expression:y                                                {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Lt, y); :}
| expression:x GREATER expression:y                                             {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Gt, y); :}
| expression:x LESSEQUAL expression:y                                           {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Le, y); :}
| expression:x GREATEREQUAL expression:y                                        {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Ge, y); :}
| expression:x EQUALEQUAL expression:y                                          {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Eq, y); :}
| expression:x NOTEQUAL expression:y                                            {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Neq, y); :}
  // Binary arithmetric expressions
| expression:x PLUS expression:y                                                {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Add, y); :}
| expression:x MINUS expression:y                                               {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Sub, y); :}
| expression:x TIMES expression:y                                               {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Mul, y); :}
| expression:x DIV expression:y                                                 {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Div, y); :}
  // List operator expressions
| GET LPAREN expression:x COMMA expression:y RPAREN                             {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Get, y); :}
| REMOVE LPAREN expression:x COMMA expression:y RPAREN                          {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Remove, y); :}
| CONTAINS LPAREN expression:x COMMA expression:y RPAREN                        {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Contains, y); :}
| ADDFIRST LPAREN expression:x COMMA expression:y RPAREN                        {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.AddFirst, y); :}
| ADDLAST LPAREN expression:x COMMA expression:y RPAREN                         {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.AddLast, y); :}
;

unary_expression ::=
  // Logical unary expressions 
  NOT expression:x                                                              {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.Not); :}
  // Unary arithmetric expressions
| MINUS expression:x                                                            {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.Neg); :}
  // Random number generation
| RANDOM LPAREN expression:x RPAREN                                             {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.Random); :}
  // List operator expressions
| REMOVEFIRST LPAREN expression:x RPAREN                                        {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.RemoveFirst); :}
| REMOVELAST LPAREN expression:x RPAREN                                         {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.RemoveLast); :}
| FIRST LPAREN expression:x RPAREN                                              {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.First); :}
| LAST LPAREN expression:x RPAREN                                               {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.Last); :}
| CLEAR LPAREN expression:x RPAREN                                              {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.Clear); :}
| EMPTY LPAREN expression:x RPAREN                                              {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.Empty); :}
| SIZE LPAREN expression:x RPAREN                                               {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.Size); :}
;

variable_expression ::=
  VARIABLE:x                                                                    {: RESULT = new SimpleVariable(x); :}
| VARIABLE:x LBRACK expression:y RBRACK                                         {: RESULT = new ArrayVariable(x, y); :}
| VARIABLE:x DOT VARIABLE:y                                                     {: RESULT = new MemberVariable(x, y); :}
;

invocation_expression ::=
  // State execution condition
  IN LPAREN VARIABLE:x RPAREN                                                   {: RESULT = new InStateCond(x); :}
  // Prolog query execution
| QUERY LPAREN expression:x RPAREN                                              {: RESULT = new PrologQuery(x); :}
  // Timeout condition 
| TIMEOUT LPAREN expression:x RPAREN                                            {: RESULT = new TimeoutFunction(x); :}
  // History functions
| HISTORY_VALUE_OF LPAREN VARIABLE:x COMMA VARIABLE:y COMMA INTEGER:z RPAREN    {: RESULT = new HistoryValueOf(x, y, z); :}
| HISTORY_VALUE_OF LPAREN VARIABLE:x COMMA VARIABLE:y RPAREN                    {: RESULT = new HistoryValueOf(x, y); :}
| HISTORY_RUNTIME LPAREN VARIABLE:x COMMA INTEGER:y RPAREN                      {: RESULT = new HistoryRunTime(x, y); :}
| HISTORY_RUNTIME LPAREN VARIABLE:x RPAREN                                      {: RESULT = new HistoryRunTime(x); :}
;

record_expression ::=
  LBRACK expression_list:x RBRACK                                               {: RESULT = new ListRecord(x); :}
| LBRACE assignment_list:x RBRACE                                               {: RESULT = new StructRecord(x); :}
;

literal_expression ::=
  NULL                                                                          {: RESULT = new NullObject(); :}
| BOOLEAN:x                                                                     {: RESULT = new BoolLiteral(x); :}
| INTEGER:x                                                                     {: RESULT = new IntLiteral(x); :}
| FLOAT:x                                                                       {: RESULT = new FloatLiteral(x); :}
| STRING:x                                                                      {: RESULT = new StringLiteral(_SFSLParser_.trimString(x)); :}
;