package de.dfki.vsm.sfsl.parser;

import de.dfki.vsm.model.sceneflow.command.AbstractCommand;
import de.dfki.vsm.model.sceneflow.command.Assignment;
import de.dfki.vsm.model.sceneflow.command.HistoryClear;
import de.dfki.vsm.model.sceneflow.command.HistorySetDepth;
import de.dfki.vsm.model.sceneflow.command.HistoryDeepClear;
import de.dfki.vsm.model.sceneflow.command.PlayDialogueAct;
import de.dfki.vsm.model.sceneflow.command.PlaySceneGroup;
import de.dfki.vsm.model.sceneflow.command.UnblockSceneGroup;
import de.dfki.vsm.model.sceneflow.command.UnblockAllSceneGroups;
import de.dfki.vsm.model.sceneflow.command.expression.ParenthesesExpression;
import de.dfki.vsm.model.sceneflow.command.expression.AbstractExpression;
import de.dfki.vsm.model.sceneflow.command.expression.UnaryExpression;
import de.dfki.vsm.model.sceneflow.command.expression.BinaryExpression;
import de.dfki.vsm.model.sceneflow.command.expression.CallingExpression;
import de.dfki.vsm.model.sceneflow.command.expression.TernaryExpression;
import de.dfki.vsm.model.sceneflow.command.expression.ConstructExpression;
import de.dfki.vsm.model.sceneflow.command.expression.constant.JavaObject;
import de.dfki.vsm.model.sceneflow.command.expression.constant.IntLiteral;
import de.dfki.vsm.model.sceneflow.command.expression.constant.FloatLiteral;
import de.dfki.vsm.model.sceneflow.command.expression.constant.BoolLiteral;
import de.dfki.vsm.model.sceneflow.command.expression.constant.StringLiteral;
import de.dfki.vsm.model.sceneflow.command.expression.constant.ListRecord;
import de.dfki.vsm.model.sceneflow.command.expression.constant.StructRecord;
import de.dfki.vsm.model.sceneflow.command.expression.constant.Constant;
import de.dfki.vsm.model.sceneflow.command.expression.lexpression.AbstractVariable;
import de.dfki.vsm.model.sceneflow.command.expression.lexpression.SimpleVariable;
import de.dfki.vsm.model.sceneflow.command.expression.lexpression.MemberVariable;
import de.dfki.vsm.model.sceneflow.command.expression.lexpression.ArrayVariable;
import de.dfki.vsm.model.sceneflow.command.expression.function.HistoryContains;
import de.dfki.vsm.model.sceneflow.command.expression.function.HistoryRunTime;
import de.dfki.vsm.model.sceneflow.command.expression.function.HistoryValueOf;
import de.dfki.vsm.model.sceneflow.command.expression.function.InStateCond;
import de.dfki.vsm.model.sceneflow.command.expression.function.StateValueOf;
import de.dfki.vsm.model.sceneflow.command.expression.function.PrologQuery;
import de.dfki.vsm.model.sceneflow.command.expression.temporal.TemporalCond;
import de.dfki.vsm.model.sceneflow.command.expression.temporal.TimeoutCond;

import java.util.ArrayList;

//import java_cup.runtime.*;
import java.io.StringReader;

parser code {:
  public static AbstractCommand cmdResult;
  public static AbstractExpression expResult;
 
  public static final short STATEMENT = 0;
  public static final short EXPRESSION = 1;

  public static short parseResultType = 0;
  public static boolean errorFlag = false;

  public static java.lang.String trimString(java.lang.String value) {    
    return value.substring(1, value.length()-1);
  }

  public static void run(java.lang.String arg) throws Exception {
    cmdResult=null;
    expResult=null;

    System.err.println("Parsing Input String '" + arg + "'"); 

    java.lang.String inputString = new java.lang.String(arg);
    StringReader stringReader = new java.io.StringReader(inputString);
    new _SFSLParser_(new _SFSLScanner_(stringReader)).parse();
  }
:};

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Binary Logical Operators
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal OR;
terminal AND; 
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Binary/Unary Arithmetric
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal DIV; 
terminal PLUS; 
terminal MINUS; 
terminal TIMES; 
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Binary List Operators
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal GET; 
terminal REMOVE; 
terminal ADDFIRST; 
terminal ADDLAST; 
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Binary Comparison Operators
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ 
terminal EQUALEQUAL; 
terminal NOTEQUAL; 
terminal LESS; 
terminal GREATER; 
terminal LESSEQUAL; 
terminal GREATEREQUAL;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal RANDOM; 
terminal REMOVEFIRST; 
terminal REMOVELAST; 
terminal FIRST; 
terminal LAST; 
terminal CLEAR; 
terminal SIZE; 
terminal EMPTY;
terminal CONTAINS;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, COMMA, QUESTION, COLON, DOT;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Unary Arithmetric Operators
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal NOT; 
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Equality Operator
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal EQUAL;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Scene and Dialog Act Play
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal PSG, PDA, USG, UASG;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal HISTORYFLATCLEAR;
terminal HISTORYDEEPCLEAR;
terminal HISTORYCONTAINS;
terminal HISTORYVALUEOF;
terminal HISTORYSETDEPTH;
terminal HISTORYRUNTIME;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal VALUEOF;
terminal TIMEOUT;
terminal QUERY;
terminal NEW;
terminal IN;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal java.lang.String VARIABLE;
terminal java.lang.Integer INTEGER; 
terminal java.lang.Float FLOAT; 
terminal java.lang.Boolean BOOLEAN;
terminal java.lang.String STRING;
terminal java.lang.Object NULL;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
non terminal InStateCond instate_condition;
non terminal StateValueOf node_value_of;
non terminal TemporalCond temporal;
non terminal TimeoutCond timeout;
non terminal HistoryValueOf history_value_of;
non terminal HistoryRunTime history_runtime_of;
non terminal PrologQuery prolog_condition;
non terminal ConstructExpression construct_expression;
non terminal CallingExpression calling_expression;
non terminal AbstractVariable variable_expression;
non terminal TernaryExpression ternary_expression;
non terminal BinaryExpression binary_expression;
non terminal UnaryExpression unary_expression;
non terminal AbstractCommand command;
non terminal Assignment assignment;
non terminal AbstractExpression parentheses_expression;
non terminal AbstractExpression expression;
non terminal AbstractExpression function;
non terminal Constant constant;
non terminal ArrayList expression_list;
non terminal ArrayList assignment_list;
non terminal ArrayList non_empty_expression_list;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Operator Precedences
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
precedence right EQUAL;
precedence left OR;
precedence left AND;
precedence left EQUALEQUAL, NOTEQUAL;
precedence left LESS, LESSEQUAL, GREATER, GREATEREQUAL;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence right NOT;
precedence left DOT;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Command Definitions
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
command ::=
  expression:x                                                                  {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } :}
| assignment:x                                                                  {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| PSG LPAREN expression:x RPAREN                                                {: RESULT = new PlaySceneGroup(x); if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| PSG LPAREN expression:x COMMA non_empty_expression_list:y RPAREN              {: RESULT = new PlaySceneGroup(x,y); if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| PDA LPAREN expression:x RPAREN                                                {: RESULT = new PlayDialogueAct(x); if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| PDA LPAREN expression:x COMMA non_empty_expression_list:y RPAREN              {: RESULT = new PlayDialogueAct(x,y); if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| USG LPAREN expression:x RPAREN                                                {: RESULT = new UnblockSceneGroup(x); if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| UASG LPAREN BOOLEAN:x RPAREN                                                  {: RESULT = new UnblockAllSceneGroups(x); if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| HISTORYFLATCLEAR LPAREN VARIABLE:x RPAREN                                     {: RESULT = new HistoryClear(x); if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| HISTORYDEEPCLEAR LPAREN VARIABLE:x RPAREN                                     {: RESULT = new HistoryDeepClear(x); if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| HISTORYSETDEPTH LPAREN VARIABLE:x COMMA INTEGER:y RPAREN                      {: RESULT = new HistorySetDepth(x,y); if(_SFSLParser_.parseResultType == _SFSLParser_.STATEMENT) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :};

/*
 * ASSIGNMENT
 */
assignment ::=
  variable_expression:x EQUAL expression:y                                              {: RESULT = new Assignment(x, y); :};

/*
 * ASSIGNMENT LIST
 */
assignment_list ::=
                                                                                {: ArrayList<Assignment> vec = new ArrayList<Assignment>(); RESULT = vec; :}
| assignment:x                                                                  {: ArrayList<Assignment> vec = new ArrayList<Assignment>(); vec.add(x); RESULT = vec; :}
| assignment_list:x COMMA assignment:y                                          {: ArrayList<Assignment> vec = x; vec.add(y); RESULT = x; :};


/*
 * NON_EMPTY _SFSLParser_.EXPRESSION LIST
 */
non_empty_expression_list ::=
  expression:x                                                                  {: ArrayList<AbstractExpression> vec = new ArrayList<AbstractExpression>(); vec.add(x); RESULT = vec; :}
| expression_list:x COMMA expression:y                                          {: ArrayList<AbstractExpression> vec = x; vec.add(y); RESULT = x; :};


/*
 * _SFSLParser_.EXPRESSION LIST
 */
expression_list ::= 
                                                                                {: ArrayList<AbstractExpression> vec = new ArrayList<AbstractExpression>(); RESULT = vec; :}
| expression:x                                                                  {: ArrayList<AbstractExpression> vec = new ArrayList<AbstractExpression>(); vec.add(x); RESULT = vec; :}
| expression_list:x COMMA expression:y                                          {: ArrayList<AbstractExpression> vec = x; vec.add(y); RESULT = x; :};

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * _SFSLParser_.EXPRESSION
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
expression ::=
  unary_expression:x                                                            {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| binary_expression:x                                                           {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| ternary_expression:x                                                          {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| calling_expression:x                                                          {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| variable_expression:x                                                         {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| construct_expression:x                                                        {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| parentheses_expression:x                                                      {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
  //
| history_value_of:x                                                            {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| history_runtime_of:x                                                          {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| node_value_of:x                                                               {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| function:x                                                                    {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| constant:x                                                                    {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| temporal:x                                                                    {: RESULT = x; if(_SFSLParser_.parseResultType == _SFSLParser_.EXPRESSION) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
;


parentheses_expression ::=
  LPAREN expression:x RPAREN                                                    {: RESULT = new ParenthesesExpression(x); :}
;

construct_expression ::=
  NEW VARIABLE:x LPAREN expression_list:y RPAREN                                {: RESULT = new ConstructExpression(x, y); :}
;

node_value_of ::=
  VALUEOF LPAREN VARIABLE:x COMMA VARIABLE:y RPAREN                             {: RESULT = new StateValueOf(x, y); :}
;

/*
 * USER COMMAND _SFSLParser_.EXPRESSION
 */
calling_expression ::=
  VARIABLE:x LPAREN expression_list:y RPAREN                                    {: RESULT = new CallingExpression(x, y); :}
;

/*
 * HISTORY VALUE _SFSLParser_.EXPRESSION
 */
history_value_of ::=
  HISTORYVALUEOF LPAREN VARIABLE:x COMMA VARIABLE:y COMMA INTEGER:z RPAREN      {: RESULT = new HistoryValueOf(x, y, z); :}
| HISTORYVALUEOF LPAREN VARIABLE:x COMMA VARIABLE:y RPAREN                      {: RESULT = new HistoryValueOf(x, y); :}
;

/*
 * HISTORY RUNTIME _SFSLParser_.EXPRESSION
 */
history_runtime_of ::=
  HISTORYRUNTIME LPAREN VARIABLE:x COMMA INTEGER:y RPAREN                     {: RESULT = new HistoryRunTime(x, y); :}
| HISTORYRUNTIME LPAREN VARIABLE:x RPAREN                                     {: RESULT = new HistoryRunTime(x); :}
;

/*
 * CONDITIONAL _SFSLParser_.EXPRESSION
 */
ternary_expression ::=
  LPAREN expression:x QUESTION expression:y COLON expression:z RPAREN            {: RESULT = new TernaryExpression(x, y, z); :}
;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * BINARY _SFSLParser_.EXPRESSION
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
binary_expression ::=

// Logical binary expressions
  expression:x AND expression:y                                                 {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.And, y); :}
| expression:x OR expression:y                                                  {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Or, y); :}

// Binary comparison expressions
| expression:x LESS expression:y                                                {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Lt, y); :}
| expression:x GREATER expression:y                                             {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Gt, y); :}
| expression:x LESSEQUAL expression:y                                           {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Le, y); :}
| expression:x GREATEREQUAL expression:y                                        {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Ge, y); :}
| expression:x EQUALEQUAL expression:y                                          {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Eq, y); :}
| expression:x NOTEQUAL expression:y                                            {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Neq, y); :}

// Binary arithmetric expressions
| expression:x PLUS expression:y                                                {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Add, y); :}
| expression:x MINUS expression:y                                               {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Sub, y); :}
| expression:x TIMES expression:y                                               {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Mul, y); :}
| expression:x DIV expression:y                                                 {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Div, y); :}

// List operator expressions
| GET LPAREN expression:x COMMA expression:y RPAREN                             {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Get, y); :}
| REMOVE LPAREN expression:x COMMA expression:y RPAREN                          {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Remove, y); :}
| CONTAINS LPAREN expression:x COMMA expression:y RPAREN                        {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.Contains, y); :}
| ADDFIRST LPAREN expression:x COMMA expression:y RPAREN                        {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.AddFirst, y); :}
| ADDLAST LPAREN expression:x COMMA expression:y RPAREN                         {: RESULT = new BinaryExpression(x, BinaryExpression.Operator.AddLast, y); :}
;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * UNARY _SFSLParser_.EXPRESSION
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
unary_expression ::=
  // Logical unary expressions 
  NOT expression:x                                                              {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.Not); :}
  
  // Unary arithmetric expressions
| MINUS expression:x                                                            {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.Neg); :}

  // Random number generation
| RANDOM LPAREN expression:x RPAREN                                             {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.Random); :}

  // List operator expressions
| REMOVEFIRST LPAREN expression:x RPAREN                                        {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.RemoveFirst); :}
| REMOVELAST LPAREN expression:x RPAREN                                         {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.RemoveLast); :}
| FIRST LPAREN expression:x RPAREN                                              {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.First); :}
| LAST LPAREN expression:x RPAREN                                               {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.Last); :}
| CLEAR LPAREN expression:x RPAREN                                              {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.Clear); :}
| EMPTY LPAREN expression:x RPAREN                                              {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.Empty); :}
| SIZE LPAREN expression:x RPAREN                                               {: RESULT = new UnaryExpression(x, UnaryExpression.Operator.Size); :}
;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * L_SFSLParser_.EXPRESSION
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
variable_expression ::=
  VARIABLE:x                                                                    {: RESULT = new SimpleVariable(x); :}
| VARIABLE:x LBRACK expression:y RBRACK                                         {: RESULT = new ArrayVariable(x, y); :}
| VARIABLE:x DOT VARIABLE:y                                                     {: RESULT = new MemberVariable(x, y); :}
;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * FUNCTION CALLS
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
function ::=
 //State execution condition
 IN LPAREN VARIABLE:x RPAREN                                                   {: RESULT = new InStateCond(x); :}
 //Prolog query execution
  | QUERY LPAREN expression:x RPAREN                                            {: RESULT = new PrologQuery(x); :}
//| QUERY LPAREN usrcmd_expression:x RPAREN                                     {: RESULT = new PrologQuery(x); :}
;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * CONSTANT LITERALS
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
constant ::=
  INTEGER:x                                                                     {: RESULT = new IntLiteral(x); :}
| FLOAT:x                                                                       {: RESULT = new FloatLiteral(x); :}
| BOOLEAN:x                                                                     {: RESULT = new BoolLiteral(x); :}
| NULL                                                                          {: RESULT = new JavaObject(); :}
| STRING:x                                                                      {: RESULT = new StringLiteral(_SFSLParser_.trimString(x)); :}
| LBRACK expression_list:x RBRACK                                               {: RESULT = new ListRecord(x); :}
| LBRACE assignment_list:x RBRACE                                               {: RESULT = new StructRecord(x); :}
;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * TEMPORAL CONDITION
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
temporal ::= timeout:x                                                          {: RESULT = x; :};
timeout ::= TIMEOUT LPAREN expression:x RPAREN                                  {: RESULT = new TimeoutCond(x); :}
;