package de.dfki.vsm.sfsl.parser;

import de.dfki.vsm.model.sceneflow.command.Command;
import de.dfki.vsm.model.sceneflow.command.Assignment;
import de.dfki.vsm.model.sceneflow.command.expression.Expression;
import de.dfki.vsm.model.sceneflow.command.expression.UsrCmd;
import de.dfki.vsm.model.sceneflow.command.expression.Constructor;
import de.dfki.vsm.model.sceneflow.command.expression.UnaryExp;
import de.dfki.vsm.model.sceneflow.command.expression.BinaryExp;
import de.dfki.vsm.model.sceneflow.command.expression.ConditionalExp;
import de.dfki.vsm.model.sceneflow.command.expression.constant.JavaObject;
import de.dfki.vsm.model.sceneflow.command.expression.constant.IntLiteral;
import de.dfki.vsm.model.sceneflow.command.expression.constant.FloatLiteral;
import de.dfki.vsm.model.sceneflow.command.expression.constant.BoolLiteral;
import de.dfki.vsm.model.sceneflow.command.expression.constant.StringLiteral;
import de.dfki.vsm.model.sceneflow.command.expression.constant.ListRecord;
import de.dfki.vsm.model.sceneflow.command.expression.constant.StructRecord;
import de.dfki.vsm.model.sceneflow.command.expression.constant.Constant;
import de.dfki.vsm.model.sceneflow.command.expression.lexpression.LExpression;
import de.dfki.vsm.model.sceneflow.command.expression.lexpression.SimpleVariable;
import de.dfki.vsm.model.sceneflow.command.expression.lexpression.MemberVariable;
import de.dfki.vsm.model.sceneflow.command.expression.lexpression.ArrayVariable;
import de.dfki.vsm.model.sceneflow.command.expression.function.HistoryContains;
import de.dfki.vsm.model.sceneflow.command.expression.function.HistoryRunTime;
import de.dfki.vsm.model.sceneflow.command.expression.function.HistoryValueOf;
import de.dfki.vsm.model.sceneflow.command.expression.function.InStateCond;
import de.dfki.vsm.model.sceneflow.command.expression.function.StateValueOf;
import de.dfki.vsm.model.sceneflow.command.expression.function.PrologQuery;
import de.dfki.vsm.model.sceneflow.command.expression.temporal.TemporalCond;
import de.dfki.vsm.model.sceneflow.command.expression.temporal.TimeoutCond;

//import java_cup.runtime.*;
import java.io.StringReader;

parser code {:
  public static Command cmdResult;
  public static Expression expResult;
 
  public static final short CMD = 0;
  public static final short EXP = 1;

  public static short parseResultType = 0;
  public static boolean errorFlag = false;

  public static java.lang.String trimString(java.lang.String value) {    
    return value.substring(1, value.length()-1);
  }

  public static void run(java.lang.String arg) throws Exception {
    cmdResult=null;
    expResult=null;

    System.err.println("Parsing " + arg); 

    java.lang.String inputString = new java.lang.String(arg);
    StringReader stringReader = new java.io.StringReader(inputString);
    new _SFSLParser_(new _SFSLScanner_(stringReader)).parse();
  }
:};

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Binary Logical Operators
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal OR;
terminal AND; 
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Binary/Unary Arithmetric
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal DIV; 
terminal PLUS; 
terminal MINUS; 
terminal TIMES; 
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Binary List Operators
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal GET; 
terminal REMOVE; 
terminal ADDFIRST; 
terminal ADDLAST; 
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Binary Comparison Operators
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ 
terminal EQUALEQUAL; 
terminal NOTEQUAL; 
terminal LESS; 
terminal GREATER; 
terminal LESSEQUAL; 
terminal GREATEREQUAL;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal RANDOM; 
terminal REMOVEFIRST; 
terminal REMOVELAST; 
terminal FIRST; 
terminal LAST; 
terminal CLEAR; 
terminal SIZE; 
terminal EMPTY;
terminal CONTAINS;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, COMMA, QUESTION, COLON, DOT, AT;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Unary Arithmetric Operators
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal NOT; 
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Equality Operator
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal EQUAL;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Scene and Dialog Act Play
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal PSG, PDA;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal HISTORYFLATCLEAR;
terminal HISTORYDEEPCLEAR;
terminal HISTORYCONTAINS;
terminal HISTORYVALUEOF;
terminal HISTORYSETDEPTH;
terminal HISTORYRUNTIME;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal VALUEOF;
terminal TIMEOUT;
terminal QUERY;
terminal PLAY;
terminal NEW;
terminal IN;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
terminal java.lang.String VARIABLE;
terminal java.lang.Integer INTEGER; 
terminal java.lang.Float FLOAT; 
terminal java.lang.Boolean BOOLEAN;
terminal java.lang.String STRING;
terminal java.lang.Object NULL;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
non terminal InStateCond instate_condition;
non terminal StateValueOf node_value_of;
non terminal TemporalCond temporal;
non terminal TimeoutCond timeout;
non terminal HistoryValueOf history_value_of;
non terminal HistoryRunTime history_runtime_of;
non terminal PrologQuery prolog_condition;
non terminal ConditionalExp conditional_expression;
non terminal BinaryExp binary_expression;
non terminal UnaryExp unary_expression;
non terminal UsrCmd usrcmd_expression;
non terminal Constructor constructor;
non terminal Command command;
non terminal Assignment assignment;
non terminal Expression expression;
non terminal Expression function;
non terminal LExpression lexpression;
non terminal Constant constant;
non terminal java.util.Vector expression_list;
non terminal java.util.Vector assignment_list;
non terminal java.util.Vector non_empty_expression_list;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Operator Precedences
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
precedence right EQUAL;
precedence left OR;
precedence left AND;
precedence left EQUALEQUAL, NOTEQUAL;
precedence left LESS, LESSEQUAL, GREATER, GREATEREQUAL;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence right NOT;
precedence left DOT;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Command Definitions
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
command ::=
  expression:x                                                                  {: RESULT = x; if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.CMD) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } :}
| assignment:x                                                                  {: RESULT = x; if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.CMD) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| PSG LPAREN expression:x RPAREN                                                {: RESULT = new de.dfki.vsm.model.sceneflow.command.PlaySceneGroup(x); if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.CMD) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| PSG LPAREN expression:x COMMA non_empty_expression_list:y RPAREN              {: RESULT = new de.dfki.vsm.model.sceneflow.command.PlaySceneGroup(x,y); if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.CMD) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| PDA LPAREN expression:x RPAREN                                                {: RESULT = new de.dfki.vsm.model.sceneflow.command.PlayDialogueAct(x); if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.CMD) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| PDA LPAREN expression:x COMMA non_empty_expression_list:y RPAREN              {: RESULT = new de.dfki.vsm.model.sceneflow.command.PlayDialogueAct(x,y); if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.CMD) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
//| USG LPAREN expression:x RPAREN                                                {: RESULT = new de.dfki.vsm.model.sceneflow.command.UnblockSceneGroup(x); if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.CMD) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
//| UASG LPAREN BOOLEAN:x RPAREN                                                  {: RESULT = new de.dfki.vsm.model.sceneflow.command.UnblockAllSceneGroups(x); if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.CMD) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| HISTORYFLATCLEAR LPAREN VARIABLE:x RPAREN                                     {: RESULT = new de.dfki.vsm.model.sceneflow.command.HistoryClear(x); if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.CMD) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| HISTORYDEEPCLEAR LPAREN VARIABLE:x RPAREN                                     {: RESULT = new de.dfki.vsm.model.sceneflow.command.HistoryDeepClear(x); if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.CMD) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :}
| HISTORYSETDEPTH LPAREN VARIABLE:x COMMA INTEGER:y RPAREN                      {: RESULT = new de.dfki.vsm.model.sceneflow.command.HistorySetDepth(x,y); if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.CMD) { _SFSLParser_.cmdResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such a command"); _SFSLParser_.errorFlag = true; } :};

/*
 * ASSIGNMENT
 */
assignment ::=
  lexpression:x EQUAL expression:y                                              {: RESULT = new de.dfki.vsm.model.sceneflow.command.Assignment(x, y); :};

/*
 * ASSIGNMENT LIST
 */
assignment_list ::=
                                                                                {: java.util.Vector<de.dfki.vsm.model.sceneflow.command.Assignment> vec = new java.util.Vector<de.dfki.vsm.model.sceneflow.command.Assignment>(); RESULT = vec; :}
| assignment:x                                                                  {: java.util.Vector<de.dfki.vsm.model.sceneflow.command.Assignment> vec = new java.util.Vector<de.dfki.vsm.model.sceneflow.command.Assignment>(); vec.add(x); RESULT = vec; :}
| assignment_list:x COMMA assignment:y                                           {: java.util.Vector<de.dfki.vsm.model.sceneflow.command.Assignment> vec = x; vec.add(y); RESULT = x; :};


/*
 * NON_EMPTY EXPRESSION LIST
 */
non_empty_expression_list ::=
  expression:x                                                                  {: java.util.Vector<de.dfki.vsm.model.sceneflow.command.expression.Expression> vec = new java.util.Vector<de.dfki.vsm.model.sceneflow.command.expression.Expression>(); vec.add(x); RESULT = vec; :}
| expression_list:x COMMA expression:y                                          {: java.util.Vector<de.dfki.vsm.model.sceneflow.command.expression.Expression> vec = x; vec.add(y); RESULT = x; :};


/*
 * EXPRESSION LIST
 */
expression_list ::= 
                                                                                {: java.util.Vector<de.dfki.vsm.model.sceneflow.command.expression.Expression> vec = new java.util.Vector<de.dfki.vsm.model.sceneflow.command.expression.Expression>(); RESULT = vec; :}
| expression:x                                                                  {: java.util.Vector<de.dfki.vsm.model.sceneflow.command.expression.Expression> vec = new java.util.Vector<de.dfki.vsm.model.sceneflow.command.expression.Expression>(); vec.add(x); RESULT = vec; :}
| expression_list:x COMMA expression:y                                          {: java.util.Vector<de.dfki.vsm.model.sceneflow.command.expression.Expression> vec = x; vec.add(y); RESULT = x; :};

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * EXPRESSION
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
expression ::=
  unary_expression:x                                                            {: RESULT = x; if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.EXP) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| binary_expression:x                                                           {: RESULT = x; if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.EXP) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| conditional_expression:x                                                      {: RESULT = x; if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.EXP) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| LPAREN binary_expression:x RPAREN                                             {: RESULT = x; if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.EXP) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| usrcmd_expression:x                                                           {: RESULT = x; if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.EXP) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| history_value_of:x                                                            {: RESULT = x; if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.EXP) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| history_runtime_of:x                                                          {: RESULT = x; if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.EXP) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| node_value_of:x                                                               {: RESULT = x; if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.EXP) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| constructor:x                                                                 {: RESULT = x; if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.EXP) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| function:x                                                                    {: RESULT = x; if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.EXP) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| constant:x                                                                    {: RESULT = x; if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.EXP) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| temporal:x                                                                    {: RESULT = x; if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.EXP) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
| lexpression:v                                                                 {: RESULT = v; if(_SFSLParser_.parseResultType == de.dfki.vsm.sfsl.parser._SFSLParser_.EXP) { _SFSLParser_.expResult = RESULT; _SFSLParser_.errorFlag = false; } else {System.out.println("We do not want to parse such an expression"); _SFSLParser_.errorFlag = true; } :}
;

constructor ::=
  NEW VARIABLE:x LPAREN expression_list:y RPAREN                                {: RESULT = new de.dfki.vsm.model.sceneflow.command.expression.Constructor(x, y); :};

node_value_of ::=
  VALUEOF LPAREN VARIABLE:x COMMA VARIABLE:y RPAREN                             {: RESULT = new StateValueOf(x, y); :};

/*
 * USER COMMAND EXPRESSION
 */
usrcmd_expression ::=
  VARIABLE:x LPAREN expression_list:y RPAREN                                    {: RESULT = new de.dfki.vsm.model.sceneflow.command.expression.UsrCmd(x, y); :};

/*
 * HISTORY VALUE EXPRESSION
 */
history_value_of ::=
  HISTORYVALUEOF LPAREN VARIABLE:x COMMA VARIABLE:y COMMA INTEGER:z RPAREN      {: RESULT = new HistoryValueOf(x, y, z); :}
| HISTORYVALUEOF LPAREN VARIABLE:x COMMA VARIABLE:y RPAREN                      {: RESULT = new HistoryValueOf(x, y); :};

/*
 * HISTORY RUNTIME EXPRESSION
 */
history_runtime_of ::=
  HISTORYRUNTIME LPAREN VARIABLE:x COMMA INTEGER:y RPAREN                     {: RESULT = new HistoryRunTime(x, y); :}
| HISTORYRUNTIME LPAREN VARIABLE:x RPAREN                                     {: RESULT = new HistoryRunTime(x); :};

/*
 * CONDITIONAL EXPRESSION
 */
conditional_expression ::=
  LPAREN expression:x QUESTION expression:y COLON expression:z RPAREN            {: RESULT = new de.dfki.vsm.model.sceneflow.command.expression.ConditionalExp(x, y, z); :};

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * BINARY EXPRESSION
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
binary_expression ::=

// Logical binary expressions
  expression:x AND expression:y                                                 {: RESULT = new BinaryExp(x, BinaryExp.Operator.And, y); :}
| expression:x OR expression:y                                                  {: RESULT = new BinaryExp(x, BinaryExp.Operator.Or, y); :}

// Binary comparison expressions
| expression:x LESS expression:y                                                {: RESULT = new BinaryExp(x, BinaryExp.Operator.Lt, y); :}
| expression:x GREATER expression:y                                             {: RESULT = new BinaryExp(x, BinaryExp.Operator.Gt, y); :}
| expression:x LESSEQUAL expression:y                                           {: RESULT = new BinaryExp(x, BinaryExp.Operator.Le, y); :}
| expression:x GREATEREQUAL expression:y                                        {: RESULT = new BinaryExp(x, BinaryExp.Operator.Ge, y); :}
| expression:x EQUALEQUAL expression:y                                          {: RESULT = new BinaryExp(x, BinaryExp.Operator.Eq, y); :}
| expression:x NOTEQUAL expression:y                                            {: RESULT = new BinaryExp(x, BinaryExp.Operator.Neq, y); :}

// Binary arithmetric expressions
| expression:x PLUS expression:y                                                {: RESULT = new BinaryExp(x, BinaryExp.Operator.Add, y); :}
| expression:x MINUS expression:y                                               {: RESULT = new BinaryExp(x, BinaryExp.Operator.Sub, y); :}
| expression:x TIMES expression:y                                               {: RESULT = new BinaryExp(x, BinaryExp.Operator.Mul, y); :}
| expression:x DIV expression:y                                                 {: RESULT = new BinaryExp(x, BinaryExp.Operator.Div, y); :}

// List operator expressions
| GET LPAREN expression:x COMMA expression:y RPAREN                             {: RESULT = new BinaryExp(x, BinaryExp.Operator.Get, y); :}
| REMOVE LPAREN expression:x COMMA expression:y RPAREN                          {: RESULT = new BinaryExp(x, BinaryExp.Operator.Remove, y); :}
| CONTAINS LPAREN expression:x COMMA expression:y RPAREN                        {: RESULT = new BinaryExp(x, BinaryExp.Operator.Contains, y); :}
| ADDFIRST LPAREN expression:x COMMA expression:y RPAREN                        {: RESULT = new BinaryExp(x, BinaryExp.Operator.AddFirst, y); :}
| ADDLAST LPAREN expression:x COMMA expression:y RPAREN                         {: RESULT = new BinaryExp(x, BinaryExp.Operator.AddLast, y); :};

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * UNARY EXPRESSION
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
unary_expression ::=
  // Logical unary expressions 
  NOT expression:x                                                              {: RESULT = new UnaryExp(x, UnaryExp.Operator.Not); :}
  
  // Unary arithmetric expressions
| MINUS expression:x                                                            {: RESULT = new UnaryExp(x, UnaryExp.Operator.Neg); :}

  // Random number generation
| RANDOM LPAREN expression:x RPAREN                                             {: RESULT = new UnaryExp(x, UnaryExp.Operator.Random); :}

  // List operator expressions
| REMOVEFIRST LPAREN expression:x RPAREN                                        {: RESULT = new UnaryExp(x, UnaryExp.Operator.RemoveFirst); :}
| REMOVELAST LPAREN expression:x RPAREN                                         {: RESULT = new UnaryExp(x, UnaryExp.Operator.RemoveLast); :}
| FIRST LPAREN expression:x RPAREN                                              {: RESULT = new UnaryExp(x, UnaryExp.Operator.First); :}
| LAST LPAREN expression:x RPAREN                                               {: RESULT = new UnaryExp(x, UnaryExp.Operator.Last); :}
| CLEAR LPAREN expression:x RPAREN                                              {: RESULT = new UnaryExp(x, UnaryExp.Operator.Clear); :}
| EMPTY LPAREN expression:x RPAREN                                              {: RESULT = new UnaryExp(x, UnaryExp.Operator.Empty); :}
| SIZE LPAREN expression:x RPAREN                                               {: RESULT = new UnaryExp(x, UnaryExp.Operator.Size); :}
;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * LEXPRESSION
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
lexpression ::=
  VARIABLE:x                                                                    {: RESULT = new SimpleVariable(x); :}
| VARIABLE:x LBRACK expression:y RBRACK                                         {: RESULT = new ArrayVariable(x, y); :}
| VARIABLE:x DOT VARIABLE:y                                                     {: RESULT = new MemberVariable(x, y); :}
;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * FUNCTION CALLS
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
function ::=
 //State execution condition
 IN LPAREN VARIABLE:x RPAREN                                                   {: RESULT = new InStateCond(x); :}
 //Prolog query execution
  | QUERY LPAREN expression:x RPAREN                                            {: RESULT = new PrologQuery(x); :}
//| QUERY LPAREN usrcmd_expression:x RPAREN                                     {: RESULT = new PrologQuery(x); :}
;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * CONSTANT LITERALS
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
constant ::=
  INTEGER:x                                                                     {: RESULT = new IntLiteral(x); :}
| FLOAT:x                                                                       {: RESULT = new FloatLiteral(x); :}
| BOOLEAN:x                                                                     {: RESULT = new BoolLiteral(x); :}
| NULL                                                                          {: RESULT = new JavaObject(); :}
| STRING:x                                                                      {: RESULT = new StringLiteral(_SFSLParser_.trimString(x)); :}
| LBRACK expression_list:x RBRACK                                               {: RESULT = new ListRecord(x); :}
| LBRACE assignment_list:x RBRACE                                               {: RESULT = new StructRecord(x); :}
;
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * TEMPORAL CONDITION
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
temporal ::= timeout:x                                                          {: RESULT = x; :};
timeout ::= TIMEOUT LPAREN expression:x RPAREN                                  {: RESULT = new TimeoutCond(x); :}
;